{
    "collab_server" : "",
    "contents" : "\n##Simulates bear data and outputs a data frame of hair samples for later subsampling, processed same way as thesis project\n\nsim.bear<- function (known, sig, traplocs, int.g0=1, behav= -.7, IH=0, sessions=2, redun = 0, inhib=.2){\n  library(sp)\n  library(mosaic)\n  library(LaplacesDemon)\n  \n  #'Defining 'observation window' in spatstat for rSSI to work properly\n  library(spatstat)\n  traprange<-owin(xrange=c(min(as.numeric(traplocs$X))-1, max(as.numeric(traplocs$X))+1),\n                  yrange=c(min(as.numeric(traplocs$Y))-1, max(as.numeric(traplocs$Y))+1))\n  traprange$units$singular<-\"meter\"\n  traprange$units$plural<-\"meters\"\n  \n  #Simulating AC's for 15 bears, with inhibition range 'r' defined by homerange radius \n  ACs<-data.frame(AC=rSSI(r = inhib, n=length(known), win = traprange, giveup = 10000),\n                  ID=known, captured=rep(FALSE,length(known)), IHconstant = abs(rnorm(n = length(known), mean=0, sd = IH)))\n  \n  BearSamps<-data.frame()\n  \n  \n  for (s in 1:sessions){ #Captures for each session\n    \n    for (b in known){ #Captures for each bear in each session\n      bAC<-as.numeric(filter(ACs, ID==b)[,c(\"AC.x\",\"AC.y\")])\n      #Euclidean distance between AC for this bear and each trap location, and subsequent half-normal capture prob\n      trapMatrix<-data.matrix(traplocs[,c(\"X\", \"Y\")])\n      dists<-data.frame(dist=spDistsN1(pts=trapMatrix, pt = bAC), trapID=traplocs$Detector)\n      dists$dist<-dists$dist*1000 #In km for some reason...\n      \n      for (h in 1:nrow(dists)){ #For each individual trap\n        # intercept capture prob + behavior effect + effect from individual heterogeneity\n        logit.g0<- int.g0 + behav*filter(ACs, ID==b)[,\"captured\"] + filter(ACs, ID==b)[,\"IHconstant\"]\n        g0<-plogis(logit.g0)\n        dists<-mutate(dists, g = g0 * dhalfnorm(scale = sig, x = dist) * 1000) #TODO: Ask john why this works \n        \n        capProb <- dists$g[h] #Default capture probability\n        IHc<-filter(ACs, ID==b)[,\"IHconstant\"]\n        \n        if ( rbinom(n=1, size=1, prob=capProb) == 1 ){ ##Coin flip - if captured (evals to 1), add a row to the samps\n          newSamp<-data.frame(type=\"BearMR\", ID = b, Period=s, site=dists$trapID[h]) #first (non-redundant) sample\n          BearSamps<-rbind(BearSamps, newSamp)\n          if (redun!=0){\n            for (v in (1:(rpois(1, (redun + exp(IHc)))))) {BearSamps<-rbind(BearSamps, newSamp)} #if redun is 0, evals to 1, only one samp\n          }\n          ACs$captured[which(known==b)] <- TRUE ##Bear is captured, next time the cap prob will change depending on 'behav'\n          \n        }\n        \n      }\n      \n    }\n    \n  }\n  BearSamps$Period<-as.numeric(BearSamps$Period)\n  return(BearSamps)\n}\n\n\n\n#'Function to fit secr on a set of already subsampled data \n\nsecr.from.samples <- function (samps, trapcsv, subtype, modEval, trial, number, size=200)  { \n  \n  if(trial!=\"t1\" && trial!=\"t2\" && trial!=\"t3\" && trial!=\"t4\" && trial!=\"t5\" && trial!=\"t6\"){return(\"invalid trial name: must be t1 to t6 for proper storage of fitted model\")}\n  \n  samps<-samps[!duplicated(samps$INDuniqID),]\n  \n  library(secr)\n  fitted<-NULL\n  \n  strt<-Sys.time()\n  patht0<-tempfile(fileext = \".csv\")\n  write.table(samps, file=patht0, sep = \",\") \n  \n  t0caphist<-read.capthist(captfile = patht0, trapfile = trapcsv, detector = 'proximity')\n  try({fitted<-secr.fit(t0caphist, model = modEval, buffer = 1000, trace = FALSE, CL=TRUE, detectfn = 0)})\n  if(!is.null(fitted)){outcome<-TRUE} else{outcome<-FALSE; print(\"Model fit failed.\")}\n  fitted$timeElapsed<-Sys.time() - strt\n  fitted$samples<-samps\n  fitted$outcome<-outcome\n  \n  #now save the object in some logical way as RDS\n  modEval<-Reduce(paste, deparse(modEval))\n  modelPathName<-gsub(pattern = \"~\", replacement = \"tilde\" , x = modEval)\n  pathRDS<-paste(\"~/Google Drive/spatialMR/data/SimulationData/\", trial, \"/\" , modelPathName , \"/\", subtype, number, \".rds\", collapse=\"\", sep=\"\")\n  saveRDS(fitted, file = pathRDS)\n}\n\n\n##' Figure out what the last model fitting was for each combo, start off there (so I don't have to do it manually)\n\nget.rds.starts<- function(){\n  starts<-data.frame()\n  for(j in c(\"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\")){\n    for (k in c(\"g0 tilde b\", \"g0 tilde b + t\", \"g0 tilde t\")){\n      \n      path<-paste(\"~/Google Drive/spatialMR/data/SimulationData/\", j, \"/\", k, sep=\"\", collapse=\"\")\n      files<-list.files(path)\n      \n      if (length(which(files == \"SimpleRandom10001.rds\"))==0){\n        newLine<-data.frame(trial=j,model=k, startno=10001)\n      }\n      else{\n        maxFile<-max(files)\n        maxFile<-strsplit(maxFile, \"\")[[1]]\n        last<-maxFile[(length(maxFile)-8):(length(maxFile)-4)] ##This will only pick spread.one (or whatever the max char subsample is in the future, but that shouldn't matter because the trials are paired, and their max numbers are the same \n        last<-as.numeric(paste(last, sep=\"\", collapse=\"\"))\n        newLine<-data.frame(trial=j,model=k, startno=last+1)\n      }\n      starts<-rbind(starts, newLine)\n      \n    }\n  }\n  colnames(starts)<-c(\"trial\", \"model\", \"startno\")\n  return(starts)\n}\n\n##Start up the subsampling and secr fitting, with the new start numbers\n\nbear.init<-function(known, trial, model, sig, n=200, traplocs, trapPath, behav=0, IH=0, sessions=12, redun=0, int.g0=.16){\n  #' Now, fit the models in parallel like in original project\n  library(doParallel)\n  library(foreach)\n  \n  #Single simulation for both fittings \n  hairsamps<-sim.bear(known = known, sig = sig, int.g0, traplocs=traplocs, behav, IH, sessions, redun)\n  \n  #setup parallel backend to use all processors - note that this is not generally recommended for\n  #computers that are actually in use, but since this was run primarily on a server and/or broken\n  #laptop, I opted to use all cores, because I don't need any cores to run other tasks. \n  cl<-makeCluster(detectCores())\n  registerDoParallel(cl)\n  foreach (l=c(\"SimpleRandom\", \"Spread.one\")) %dopar% {\n    source('~/Google Drive/spatialMR/Rscripts/Simulation/Spatial.R') ##source this script on each core so that all functions exist...\n    source('~/Google Drive/spatialMR/Rscripts/BearSubsample.R') ##subsampling functions\n    j<-trial\n    k<-model\n    library(spatstat)\n    library(secr)\n    library(LaplacesDemon)\n    library(mosaic)\n    library(sp)\n    library(foreach)\n    \n    \n    starts<-get.rds.starts()\n    notilde<-gsub(pattern = \"~\", replacement = \"tilde\" , x = k)\n    startno<-filter(starts, trial==j, model==notilde)[,\"startno\"]\n    hairsamps<-BearSubsample(data = hairsamps, type = l, n)\n    secr.from.samples(samps = hairsamps, trapcsv = trapPath, modEval = as.formula(k),\n                      trial = j, number = startno, subtype = l, size = 200)\n    \n  }\n}\n\n##'putting it all together in one-line function...\nbear.setup<-function(){\n  ##create trap locations\n  library(secr)\n  setwd(\"~/Google Drive/spatialMR/Rscripts/Simulation\")\n  traplocs<-make.grid(nx=6, ny=6, spacing = 800)\n  traplocs[,3]<-rownames(traplocs)\n  colnames(traplocs)<-c(\"x\",\"y\",\"detectorID\")\n  traplocs2<-cbind(traplocs$detectorID, traplocs$x, traplocs$y)\n  traplocs2<-as.data.frame(traplocs2)\n  colnames(traplocs2)<-c(\"Detector\", \"X\", \"Y\") #Mimicing efford documentation to HOPEFULLY get it to work...\n  rownames(traplocs2)<-rownames(traplocs)\n  traplocs<-traplocs2\n  trapPath<-tempfile(fileext = \".csv\")\n  write.table(x = traplocs, file = trapPath, sep=\",\", col.names = FALSE, row.names = FALSE) #needed to drop rownames and colnames!  \n  ##Genetically identified individuals (instead of 16-34-299 for eg, letters for simplicity)\n  known<-c(letters, LETTERS, c(\"Aa\", \"Bb\", \"Cc\", \"Dd\", \"Ee\", \"Ff\", \"Gg\",\"Hh\"))[1:30] ##60 known bears\n  sig<-sqrt(3/pi) / 1000\n  \n  for(p in 1:10000){\n    bear.init(known, sig, model=\"g0 ~ b\", trial = \"t1\", int.g0 = 1, behav = 0, IH=0, redun=0, sessions=4, traplocs = traplocs, trapPath = trapPath)\n    bear.init(known, sig, model=\"g0 ~ b\", trial = \"t4\", int.g0 = 1, behav = 0, IH=0, redun=1, sessions=3, traplocs = traplocs, trapPath = trapPath)\n    bear.init(known, sig, model=\"g0 ~ b\", trial = \"t3\", int.g0 = 1, behav = 0, IH=1.25, redun=0, sessions=3, traplocs = traplocs, trapPath = trapPath)\n    bear.init(known, sig, model=\"g0 ~ b\", trial = \"t2\", int.g0 = 1, behav = -.7, IH=0, redun=0, sessions=4, traplocs = traplocs, trapPath = trapPath)\n    bear.init(known, sig, model=\"g0 ~ b\", trial = \"t5\", int.g0 = 1, behav = 0, IH=1.25, redun=1, sessions=3, traplocs = traplocs, trapPath = trapPath)\n    bear.init(known, sig, model=\"g0 ~ b\", trial = \"t6\", int.g0 = 1, behav = -.7, IH=1.25, redun=1, sessions=3, traplocs = traplocs, trapPath = trapPath)\n    \n  }\n}  \n",
    "created" : 1474559401281.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4186913065",
    "id" : "2367330",
    "lastKnownWriteTime" : 1474559837,
    "last_content_update" : 1474559838528,
    "path" : "I:/spatialMR/Rscripts/Simulation/Spatial.R",
    "project_path" : "Simulation/Spatial.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}