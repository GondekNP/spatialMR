{
    "collab_server" : "",
    "contents" : "##'First step is to create a systematic grid of traps 8x8 in dataframe\nlibrary(secr)\ntraplocs<-make.grid(nx=10, ny=10, spacing = .8)\n\n##'Genetically identified individuals (instead of 16-34-299, a letter for simplicity)\nknown<-c(letters, LETTERS, c(\"Aa\", \"Bb\", \"Cc\", \"Dd\", \"Ee\", \"Ff\", \"Gg\",\"Hh\", \"Ii\", \"Jj\"))\nsig<-sqrt(10/pi) #avg homerange 10 sq km (Sollman, Gardner, Belant 2012)\n\n#'Defining 'observation window' in spatstat\nlibrary(spatstat)\ntraprange<-owin(xrange=c(min(traplocs$x)-1,max(traplocs$x)+1),\n                yrange=c(min(traplocs$y)-1,max(traplocs$y)+1))\ntraprange$units$singular<-\"kilometer\"\ntraprange$units$plural<-\"kilometers\"\n\n#'Example simple sequential inhibition\nplot(traprange, main=\"Example Simulated Activity Centers \\n(X), and Trap Locations (o)\")\npoints(traplocs)\npoints(rSSI(r = sig/2, n=length(known), win = traprange, giveup = 10000), pch=\"X\")\n\n\nsim.bear<- function (known, sig, trapsxy, int.g0=.08, behav= -.02, IH=0, sessions=2, redun = 0){\n  library(sp)\n  library(mosaic)\n  library(LaplacesDemon)\n  #Simulating AC's for 15 bears, with inhibition range 'r' defined by homerange radius \n  ACs<-data.frame(AC=rSSI(r = sig/2, n=length(known), win = traprange, giveup = 10000),\n                          ID=known, captured=rep(FALSE,length(known)), IHconstant = abs(rnorm(n = length(known), mean = 0, sd = IH)))\n  BearSamps<-data.frame()\n  \n  \n  for (s in 1:sessions){ #Captures for each session\n    \n     for (b in known){ #Captures for each bear in each session\n       bAC<-as.numeric(filter(ACs, ID==b)[,c(\"AC.x\",\"AC.y\")])\n       #Euclidean distance between AC for this bear and each trap location, and subsequent half-normal capture prob\n       dists<-data.frame(dist=spDistsN1(pts=as.matrix(trapsxy), pt = bAC), trapID=rownames(trapsxy))\n       # intercept capture prob + behavior effect + effect from individual heterogeneity\n       log.g0<- log(int.g0 + behav*filter(ACs, ID==b)[,\"captured\"]) + filter(ACs, ID==b)[,\"IHconstant\"]\n       g0<-exp(log.g0)\n       dists<-mutate(dists, g = g0 * dhalfnorm(scale = 1.5*sig, x = dist)) \n       \n       for (h in 1:nrow(dists)){ #For each individual trap\n         capProb <- dists$g[h] #Default capture probability\n         if ( rbinom(n=1, size=1, prob=capProb) == 1 ){ ##Coin flip - if captured (evals to 1), add a row to the samps\n           newSamp<-data.frame(type=\"BearMR\", ID = b, Period=s, Trap=dists$trapID[h]) #first (non-redundant) sample\n            for (v in (1:(rpois(1, redun) + 1))) {BearSamps<-rbind(BearSamps, newSamp)} #if redun is 0, evals to 1, only one samp\n           ACs$captured[which(known==b)] <- TRUE ##Bear is captured, next time the cap prob will change depending on 'behav'\n         }\n         \n       }\n       \n     }\n  \n  }\n  return(BearSamps)\n}\n\n#' Testing it out - four scenarios. \n#' \n#' i) samples determined solely by half-normal\n#' \n#' ii) detections determined by halfnormal with variable g0 (which is CONSTANT for the simulation for each individual)\n#' \n#' iii) same as i or ii, but including a behavioral effect with captures being more (or less) likely following initial capture\n#' \n#' iv) same as above (i - iii), but with redundant data introduced by way of poisson distribution. \n\n\n#'\n#' i) samples determined solely by half-normal\nt1<-sim.bear(known = known, sig = sig, int.g0 = .16, trapsxy = traplocs, behav=0, IH=0, sessions=6, redun=0)\ntally(~ID,data=t1)\ntally(~Period, data=t1)\n\n#' ii) detections determined by halfnormal with variable g0 (which is CONSTANT for the simulation for each individual)\n#' \n#' IH = .1 creates a random normal value on a normal dist with an sd of .1. That constant becomes an additive contstant for the log function g0.\nt2<-sim.bear(known = known, sig = sig, int.g0 = .16, trapsxy = traplocs, behav=0, IH=.1, sessions=6, redun=0)\ntally(~ID,data=t2)\ntally(~Period, data=t2)\n\n#' iii) same as i or ii, but including a behavioral effect with captures being more (or less) likely following initial capture\n#' \n#' If the bear has been captured previously (ie left a single sample already), the behavioral constant becomes a multiplier for the half-normal distribution of capture probabilties.\nt3<-sim.bear(known = known, sig = sig, int.g0 = .16, trapsxy = traplocs, behav= -.04, IH=0, sessions=6, redun=0)\ntally(~ID,data=t3)\ntally(~Period, data=t3)\n\n#' iv) same as above (i - iii), but with redundant data introduced by way of poisson distribution.\n#' \n#' After a bear is detected at a trap, redundant samples are added by way of a random value taken from a poisson distribution with lambda equal to 'redun'\nt4<-sim.bear(known = known, sig = sig, int.g0 = .16, trapsxy = traplocs, behav=0, IH=0, sessions=6, redun=1.5)\ntally(~ID,data=t4)\ntally(~Period, data=t4)\n\n\n#' Figuring out how to fit to sim data - start by building capture history from samps and detector locations\n\n#first need the names of traps as a col and not as rownames\ntraplocs<-make.grid(nx=10, ny=10, spacing = .8)\ntraplocs[,3]<-rownames(traplocs)\ncolnames(traplocs)<-c(\"x\",\"y\",\"detectorID\")\ntraplocs2<-cbind(traplocs$detectorID, traplocs$x, traplocs$y)\ntraplocs<-as.data.frame(traplocs2)\ncolnames(traplocs)<-c(\"Detector\", \"X\", \"Y\") #Mimicing efford documentation to HOPEFULLY get it to work...\n\ntrapPath<-tempfile(fileext = \".csv\")\nwrite.table(x = traplocs, file = trapPath, sep=\",\", col.names = FALSE, row.names = FALSE) #needed to drop rownames and colnames!\n\nhead(read.csv(trapPath))\n\n#' Now, fit the models in parallel like in original project\nlibrary(doParallel)\nlibrary(foreach)\n\n\nsecr.from.samples <- function (samps, trapcsv)  { \n  \n  #use all but one processor\n  cl<-makeCluster(detectCores())\n  registerDoParallel(cl)\n  times<-data.frame()\n  \n  #for (d in 1:3){\n  foreach(d=1:3) %dopar% {\n      #in parallel, libraries need to be loaded independently\n      library(secr)\n      fitted<-list(NULL, NULL, NULL)\n      models<-list(list(g0~b+t), list(g0~t), list(g0~b))\n      modelEval<-models[[d]]\n      strt<-Sys.time()\n      patht0<-tempfile(fileext = \".csv\")\n      write.table(samps, file=patht0, sep = \",\") \n      \n      t0caphist<-read.capthist(captfile = patht0, trapfile = trapcsv, detector = 'proximity')\n      try({fitted[[d]]<-secr.fit(t0caphist, model = modelEval, buffer = 10, trace = FALSE, CL=TRUE, detectfn = 0)})\n      \n      if(is.null(fitted[[d]])){outcome<-FALSE; print(\"Model fit failed.\")}\n      time<-Sys.time() - strt\n      newTime<-data.frame(time, as.character(modelEval), outcome)\n      times<-rbind(times, newTime)\n      \n    }\n  \n  print(times)\n  return(fitted)\n}\n\n\nsecr.from.samples(t1, trapcsv = trapPath)\n\nsecr.from.samples(t2, trapcsv = trapPath)\n\nsecr.from.samples(t3, trapcsv = trapPath)\n\nsecr.from.samples(t4, trapcsv = trapPath)",
    "created" : 1473710608189.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3168242985",
    "id" : "5E7204E8",
    "lastKnownWriteTime" : 1473731904,
    "last_content_update" : 1473731904914,
    "path" : "~/GoogleDrive/spatialMR/Rscripts/Simulation/Spatial.R",
    "project_path" : "Simulation/Spatial.R",
    "properties" : {
        "source_window_id" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}